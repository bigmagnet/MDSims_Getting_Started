# This script was generated by OpenMM-Setup on 2023-02-28.

import sys
from openmm import *
from openmm.app import *
from simtk.unit import *
import time
import configparser
from params_validate import validate_section

# start the clock
start = time.time()

# read in parameters
params = validate_section(sys.argv[1], 'openmm')

files = configparser.ConfigParser()
files.read(sys.argv[2])
files = files['files']

# Input Files

prmtop = AmberPrmtopFile(files['prmtop'])
inpcrd = AmberInpcrdFile(files['inpcrd'])

# System Configuration

nonbondedMethod = PME
nonbondedCutoff = 1.4*nanometers
#nonbondedCutoff = 0.7*nanometers
ewaldErrorTolerance = 0.0005
constraints = None
rigidWater = True

# Integration Options

dt = 0.001*picoseconds
friction = 1.0/picosecond
pressure = 1.0*atmospheres
barostatInterval = 25

# Simulation Options
params['temp_step_size'] = (params['initial_temp'] - params['final_temp'])/params['temp_steps']
params['steps_per_temp'] = int(params['equil_steps']/params['temp_steps'])

# intdroduce boolean to turn GPU on or off
if params['gpu']:
    platform = Platform.getPlatformByName('CUDA') #For CUDA, use 'CUDA'
    platformProperties = {'Precision': 'double'} #For CUDA, use 'Precision': 'double' or 'mixed' (for accuracy and speed, respectively.
else:
    platform = Platform.getPlatformByName('CPU')
    platformProperties = {}
# pdbReporter = PDBReporter(sys.argv[5], steps)
dcd_interval = 100
dcdReporter = DCDReporter(files['dcd'], dcd_interval)
dataReporter = StateDataReporter(files['openmm_log'], 1000, totalSteps=params['equil_steps'],
    step=True, time=True, speed=True, progress=True, elapsedTime=True, remainingTime=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True, volume=True, density=True, separator='\t')

# Prepare the Simulation

print('Building system...')
topology = prmtop.topology
positions = inpcrd.positions
system = prmtop.createSystem(nonbondedMethod=nonbondedMethod, nonbondedCutoff=nonbondedCutoff,
    constraints=constraints, rigidWater=rigidWater, ewaldErrorTolerance=ewaldErrorTolerance)
# system.addForce(MonteCarloBarostat(pressure, temperature, barostatInterval))
#integrator = LangevinMiddleIntegrator(params['initial_temp']*kelvin, friction, dt)
integrator = VerletIntegrator(dt)
simulation = Simulation(topology, system, integrator)
simulation.context.setPositions(positions)
# print(f"inpcrd.boxVectors is {inpcrd.boxVectors}\n")
if inpcrd.boxVectors is not None:
    print(f"inpcrd.boxVectors is {inpcrd.boxVectors}\n")
    simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)

# Minimize and Equilibrate

print('Performing energy minimization...')
simulation.minimizeEnergy()
print('Equilibrating...')
simulation.reporters.append(dataReporter)
for i in range(int(params['equil_steps']/params['v_to_t_steps'])):
    simulation.step(params['v_to_t_steps'])
    simulation.context.setVelocitiesToTemperature(params['final_temp'])


# Simulate
print('Simulating...')
simulation.reporters.append(dcdReporter)
# simulation.reporters.append(pdbReporter)
simulation.currentStep = 0
simulation.step(params['sim_steps'])


# end simulation section -- now to write the simulation parameters to the results file
params['num_trajectory_frames'] = params['sim_steps']/dcd_interval
params['run_time'] = params['sim_steps']*dt
params['frame_spacing'] = params['run_time']/params['num_trajectory_frames']
params['equil_time'] = params['equil_steps']*dt

with open(files['results'], 'w') as f:
    f.write('Openmm\n')
    f.write('All temperatures are in Kelvin.\n')
    for key in params:
        f.write(key+' = '+str(params[key])+'\n')
    f.write('script run time = '+time.strftime('%H:%M:%S', time.gmtime(time.time()-start))+'\n\n')