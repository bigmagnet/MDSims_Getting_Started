# This script was generated by OpenMM-Setup on 2023-02-28.

import sys
from openmm import *
from openmm.app import *
from simtk.unit import *
import time

#start the clock
start = time.time()

# Input Files

prmtop = AmberPrmtopFile(sys.argv[1])
inpcrd = AmberInpcrdFile(sys.argv[2])

# System Configuration

nonbondedMethod = PME
#nonbondedCutoff = 1.4*nanometers
nonbondedCutoff = 0.7*nanometers
ewaldErrorTolerance = 0.0005
constraints = None
rigidWater = True

# Integration Options

dt = 0.001*picoseconds
friction = 1.0/picosecond
pressure = 1.0*atmospheres
barostatInterval = 25

# Simulation Options

steps = 20000
# added variables to make it easy to follow
initial_temperature = 700*kelvin
num_temp_steps = 50
final_temp = 293*kelvin
equilibrationSteps = 20000
temp_step_size = (initial_temperature - final_temp)/num_temp_steps
num_steps_per_temp = int(equilibrationSteps/num_temp_steps)

# intdroduce boolean to turn GPU on or off
GPU = True
if GPU:
    platform = Platform.getPlatformByName('CUDA') #For CUDA, use 'CUDA'
    platformProperties = {'Precision': 'double'} #For CUDA, use 'Precision': 'double' or 'mixed' (for accuracy and speed, respectively.
else:
    platform = Platform.getPlatformByName('CPU')
    platformProperties = {}
# pdbReporter = PDBReporter(sys.argv[5], steps)
dcd_interval = 100
dcdReporter = DCDReporter(sys.argv[3], dcd_interval)
dataReporter = StateDataReporter(sys.argv[4], 1000, totalSteps=steps,
    step=True, time=True, speed=True, progress=True, elapsedTime=True, remainingTime=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True, volume=True, density=True, separator='\t')

# Prepare the Simulation

print('Building system...')
topology = prmtop.topology
positions = inpcrd.positions
system = prmtop.createSystem(nonbondedMethod=nonbondedMethod, nonbondedCutoff=nonbondedCutoff,
    constraints=constraints, rigidWater=rigidWater, ewaldErrorTolerance=ewaldErrorTolerance)
# system.addForce(MonteCarloBarostat(pressure, temperature, barostatInterval))
integrator = LangevinMiddleIntegrator(initial_temperature, friction, dt)
# integrator = VerletIntegrator(dt)
simulation = Simulation(topology, system, integrator)
simulation.context.setPositions(positions)
# print(f"inpcrd.boxVectors is {inpcrd.boxVectors}\n")
if inpcrd.boxVectors is not None:
    print(f"inpcrd.boxVectors is {inpcrd.boxVectors}\n")
    simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)

# Minimize and Equilibrate

print('Performing energy minimization...')
simulation.minimizeEnergy()
# print('Equilibrating...')
for i in range(num_temp_steps):
    integrator.setTemperature(initial_temperature-(temp_step_size*i))
    simulation.step(num_steps_per_temp)
# simulation.context.setVelocitiesToTemperature(temperature)
# simulation.step(equilibrationSteps)

# Simulate
print('Simulating...')
integrator.setTemperature(final_temp)
simulation.reporters.append(dcdReporter)
simulation.reporters.append(dataReporter)
# simulation.reporters.append(pdbReporter)
simulation.currentStep = 0
simulation.step(steps)
# for i in range(200):
#     integrator.setTemperature(3*(300-i)*kelvin)
#     simulation.step(1000)

# end simulation section -- now to write the simulation parameters to the results file
num_frames = steps/dcd_interval
run_time = steps*dt
frame_spacing = run_time/num_frames

equil_time = (((initial_temperature - final_temp)/temp_step_size)*num_steps_per_temp)*dt

with open(sys.argv[5], 'w') as f:
    f.write('script called: openmm_sim_anneal.py\n')
    f.write('script run time = '+time.strftime('%H:%M:%S', time.gmtime(time.time()-start))+'\n')
    f.write('GPU used? ')
    if GPU:
        f.write('yes\n')
    else:
        f.write('no\n')
    f.write('simmulated annealing parameters: \n')
    f.write('start temp: '+str(initial_temperature)+'\n')
    f.write('end temp: '+str(final_temp)+'\n')
    f.write('equilibration time: '+str(equil_time)+'\n')
    f.write('temperature step size: '+str(temp_step_size)+'\n')
    f.write('time at each temperature: '+str(num_steps_per_temp*dt)+'\n')
    f.write('simulation parameters: \n')
    f.write('time step = '+str(dt)+'\n')
    f.write('simulation length = '+str(run_time)+'\n')
    f.write('number of frames = '+str(int(num_frames))+'\n')
    f.write('frame spacing = '+str(frame_spacing)+'\n\n')